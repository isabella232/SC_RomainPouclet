# Generating localization

## Screencast Title

Type-Safe Resources with SwiftGen: generating localization keys

## Screencast Description

## Language, Editor and Platform versions used in this screencast:

* Language: Swift 4
* Platform: iOS 11
* Editor: Xcode 9

## Introduction


## Talking head

Congratulations on making it this far! Your application is now working well and a lot of people are curious about your favourite social network. There is only one problem: they don’t all speak English!

Localization is a very complex topic and the complexity increases when you add new localizations.

For that reason, there are a couple of things you need to think about.

First, Localization should never be an afterthought. If you keep postponing it as a task you’ll take care of at the end of the project, right with the tests and the documentation, you’re going to suffer.

Plus, you need to use a tool that you can trust. Just like all the previous examples, localizations strings are just that: strings. Even if your application is not necessarily going to crash because you use a localization key that doesn’t exist, the user experience will be altered, and that’s not something you want.

There have been several attempts at preventing this kind of issues: command line tools, 3rd party services, and even Xcode extensions.

Let’s see how to use SwiftGen to generate code based on your localization strings.

(In Xcode)

Open the `Localizables.string` file in Xcode and look at the keys that we use. They are really simple and are used in the profile detail screen to confirm that you want to visit a specific profile page. The `message` one is the most interesting because it contains a placeholder for the name of the social media.

If you open the `ProfileViewController.swift` file, you’ll see that the way it works is not great: we’re creating a `String` using String’s `init(format:arguments:)` method and use the value in `profile_confirm_message` as the string to format.

Not only this doesn’t look like nice code, there is no indication to the arguments expected in the strings nor their types. This is one more reason to consider using a tool like SwiftGen: eliminating uncertainty. Once again, your application will not necessarily crash if you forget one argument or use the wrong format. It will however,  provide a less enjoyable experience for your users.

(In a shell)

Let’s look at the `strings` command, which works the exact same way at the previous ones: it expects a template, a file to write the generated code into and a path to your string file(s) to parse.

 Runs `Pods/SwiftGen/bin/swiftgen strings --help`

What’s more interesting is that, contrary to the other commands, SwiftGen is bundled with 2 templates for swift4: a “flat” template and a structured one.

Let’s have a look at the code generated by the flat template first.

 Runs  `Pods/SwiftGen/bin/swiftgen strings -t flat-swift4 --output RW-SwiftGen-SocialProfiles/Generated/I18N.swift RW-SwiftGen-SocialProfiles/Resources/Localizable.strings`

(In Xcode)

Right click on the Generated folder and add the generated `I18N.swift`file to your project. Once again, don’t forget to build your app to make sure nothing broke yet.

As you can see, the flat template is quite simple. For each key in your `Localizables.string`, it generates a property in the `L10n` enum that was created.

What is interesting to note is that when the string doesn’t have any placeholders, it’s exposed as a string constant in the L10N enum. On the other hand, when the strings does have placeholders, it generates a function that takes as many parameters as there are placeholders.

Using the flat template versus the structured one is a matter of preferences. I, for one prefer it over the flat one.

The command to generate a structured localization file is the same as before, we just need to change the template option:

 Runs  `Pods/SwiftGen/bin/swiftgen strings -t structured-swift4 --output RW-SwiftGen-SocialProfiles/Generated/I18N.swift RW-SwiftGen-SocialProfiles/Resources/Localizable.strings`

Go back to the I18N file.

As you can see, the “structured” template split the key and created a hierarchy of enums and properties.

Open the `ProfileViewController.swift` and replace the instances of localized string with the generated code:

```swift
let alert = UIAlertController(
    title: L10n.Profile.Confirm.title,
    message: L10n.Profile.Confirm.message(profile.name),
    preferredStyle: .alert
)

alert.addAction(UIAlertAction(
    title: L10n.Profile.Confirm.cancel,
    style: .cancel) { [weak self] _ in
        self?.dismiss(animated: true, completion: nil)
})

alert.addAction(UIAlertAction(
    title: L10n.Profile.Confirm.ok,
    style: .default) { [weak self] _ in
        self?.visit(profile.url)
})
```

Once again, using the flat or structured template is a matter of choice for you and your team. I do feel the structured template is better, especially in an application with many localization keys.

That’s it for this course, one key thing to remember is that relying on the string keys is a recipe for disaster and SwiftGen makes it really easy to write a cleaner code, where you now exactly which (and what type of!) placeholders are expected.

In the next section, we’ll wrap up and see how we can setup the project so we don’t have to remember to run SwiftGen every time you or someone from your team changes something in your project’s ressources.

## Conclusion
